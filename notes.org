
* dependencies
 - python-gudev
 - python-gobject
 - python-dbus
 - python-serial
 - python-daemon
 - lxml

* required reading
** daemon
http://www.python.org/dev/peps/pep-3143/
** dbus
http://excid3.com/blog/an-actually-decent-python-dbus-tutorial/
http://dbus.freedesktop.org/doc/dbus-python/doc/tutorial.html
http://dbus.freedesktop.org/doc/dbus-tutorial.html
http://wiki.python.org/moin/DbusExamples
*** notes on terminology and addressing
glossary: http://dbus.freedesktop.org/doc/dbus-specification.html#idp7786800

**** BUSNAME
http://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus
The busname for this project is going to be "org.voxelpress.hardware".

**** Object Paths
***** /org/voxelpress/hardware 
Is the path for the "switchboard", which enumerates what hardware is
available and probably contains a bunch of functions that are used to
communicate between the switchboard and detected hardwares' respective
subproceses.

***** /org/voxelpress/hardware/UUID
Is the path form for the detected devices, as well as later on, the
configured device proxies.


** udev
http://www.freedesktop.org/software/systemd/gudev/
http://www.freedesktop.org/software/systemd/libudev/
** linux init script stuff
?

* todo list
** DONE create a basic package
   CLOSED: [2013-05-24 Fri 12:00]
** DONE verify that the architecture is using dbus correctly
   CLOSED: [2013-05-24 Fri 12:31]
** DONE create the basic dbus service
   CLOSED: [2013-05-24 Fri 12:49]
** DONE write/adapt the udev module
   CLOSED: [2013-05-24 Fri 13:16]
** TODO add a really basic drive framework
and integrate it with the hardware detection thing.

Currently what happens when something is plugged in or removed, the
hardare thing launches a subprocess, with info about the hardware.

The subprocess then hits the drivers to do their detection thing... it
may as well at this point be a thing where the subprocess just becomes
the driver subproces.

Thus, it makes most sense for the driver to not have a manifest, but
rather a __init__.py, which provide an INFO dict, and defines a class
named Driver.



** TODO add a device driver for arduino repraps
** TODO add dbus interfaces to device driver
** TODO daemonize and create init script
This is both to report to the main thread that something was
enumerated or denumerated, and also to provide an interface in which
other programs can connect to the printer.

* radical architecting
Idk why I threw in the word "radical".  Sounds cool though.

For starters, this program represents only what is connected - and
other programs may do so as well.  I'm taking the quick-and-dirty
approach here, so I'm not only supporting sprinter derivative repraps
firmwares running on arduinos and arduino clones.

This entire component will probably be thrown out whole-sale at some
point, ethier due to obsolecence or it recieving lots of improvements.
For example, supporting the repetier protocol would be neat.  So would
support for makerbots.  But neither of those are really priorities for
me, though they may be priorities for other people to try to add.

** at the bottom
A little init script that spawns or kills the daemon.  The daemon
subprocess should instance a class that reprepsents the main dbus
interface, which should probably be something like
org.voxelpress.hardware or something.

** hardware detection
Udev events can probably be processed in the same process as the
daemon, but should be in a separate submodule, to make things cleaner.

** hardware drivers
Drivers in this case are additional modules (for now, there's going to
just be sprinter repraps).  Drivers are responsible for identifying
themselves.  A driver module is both imported by the main thread to
determine what events it can hook into, and can also call itself as a
subprocess.

The driver subprocess provides a dbus interface.  This does not
interact with the main thread, beyond reporting that the device is
attached or the device has been detached.

** printer control api
Printers can be accessed simultaneously by several other programs.
Anyone can read the printer's state, and send manual commands or start
up a stream.

When a command stream is created, the host software pasess a uuid to
represent the stream.  This functions like a lock - the program then
can proceed to dump commands into the stream, and then finishes by
closing the stream.  These commands are buffered, thus allowing the
program to be closed.

While other programs cannot add to the stream without knowing the
uuid, they can pause the print, as well as discard the stream.  There
is only one stream in memory at a time.

The control api should likely have calls for basic actions, like "move
axis", "heat up extruder n to k", "home", "set zero", and so on.

This would allow for host software to be written without hardcoding
anything like gcode.

** printer control lib
switchprint may as well just provide an api thats easy to use that
encapsulates the dbus api.
