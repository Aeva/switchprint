
* dependencies
 - python-gudev
 - python-gobject
 - python-dbus
 - python-serial
 - python-daemon

* required reading
** daemon
http://www.python.org/dev/peps/pep-3143/
** dbus
http://excid3.com/blog/an-actually-decent-python-dbus-tutorial/
http://dbus.freedesktop.org/doc/dbus-python/doc/tutorial.html
http://dbus.freedesktop.org/doc/dbus-tutorial.html
http://wiki.python.org/moin/DbusExamples
*** notes on terminology and addressing
glossary: http://dbus.freedesktop.org/doc/dbus-specification.html#idp7786800

**** BUSNAME
http://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names-bus
The busname for this project is going to be "org.voxelpress.hardware".

**** Object Paths
***** /org/voxelpress/hardware 
Is the path for the "switchboard", which enumerates what hardware is
available and probably contains a bunch of functions that are used to
communicate between the switchboard and detected hardwares' respective
subproceses.

***** /org/voxelpress/hardware/UUID
Is the path form for the detected devices, as well as later on, the
configured device proxies.

** udev
http://www.freedesktop.org/software/systemd/gudev/
http://www.freedesktop.org/software/systemd/libudev/
** linux init script stuff
?

* to-do list
** DONE create a basic package
   CLOSED: [2013-05-24 Fri 12:00]
** DONE verify that the architecture is using dbus correctly
   CLOSED: [2013-05-24 Fri 12:31]
** DONE create the basic dbus service
   CLOSED: [2013-05-24 Fri 12:49]
** DONE write/adapt the udev module
   CLOSED: [2013-05-24 Fri 13:16]
** DONE add a really basic drive framework
   CLOSED: [2013-05-27 Mon 11:37]
and integrate it with the hardware detection thing.

Currently what happens when something is plugged in or removed, the
hardare thing launches a subprocess, with info about the hardware.

The subprocess then hits the drivers to do their detection thing... it
may as well at this point be a thing where the subprocess just becomes
the driver subproces.

Thus, it makes most sense for the driver to not have a manifest, but
rather a __init__.py, which provide an INFO dict, and defines a class
named Driver.

*** switchprint._hardware
The connect event will look something like this on linux:
"tty /dev/bus/usb/001/006 /dev/ttyACM0 blahblahblah"

While the disconnect event has this info:
tty /dev/bus/usb/001/006

While there is no need for the hardware detection to connect to the
main thread for anything relating to the on_connect event, the
information about the device should be stored in the resulting object,
so that when the disconnect event happened, the appropriate service
can be introspected, and then a teardown event be called upon it.
Which, I guess, still doesn't require the main thread =)

*** writing drivers
I'm currently at a loss of a good framework.  I'll need to think on
this further.  Essentially, dynamic loading of modules is a pain in
the ass, and there doesn't seem to be a good way to trick python into
loading all of the submodules of a driver folder and using __init__.py
to call a registration function on each.

setup.py entrypoints supposedly can be used for plugin functionality,
which seems like an appropriate thing to do in this case.

** DONE add a device driver for arduino repraps
   CLOSED: [2013-05-27 Mon 17:04]
** TODO restructure program for clarity
** DONE clean up the hardware "service" model
   CLOSED: [2013-05-30 Thu 13:41]
*** problem
When a relevant udev hardware event happens, the main thread spawns a
subprocess to take care of it.  This code was moved out of the
hardware monitor's file and into its own, called udev_service.  This
file then does the hw detection, despite no longer being
platform-specific.  It does inherit from a more general subclass, but
the distinction while in the gise of separating platform specific code
is actually just to squirrel away dbus stuff.

Devices currently just implement a class, which is the Driver class.
This is probably fine.  The driver class does auto detect stuff.  When
a Driver claims a printer, the "service" class then "turns into" a
dbus service by calling it's parent class's init function.

I find this counter-intuitive and confusing, and it makes it unclear
on how I need to expand upon it.

*** possible alternative
Here's a possible alternative: the udev hardware monitor spawns a
worker suprocess for each event.  This subprocess then creates a class
representing the worker to handle different events.  When the
on_connect event handles and is able to produce a driver, another
class is instanced for the dbus server, which is passed the driver
object, and before the thread drops into the main loop.

For an on-disconnect event, the path that would have been used by the
dbus service should be still determined, so that the worker can call
the dbus stuff on whatever other worker had been handling the printer.
Both workers end up "returning" as a result.

*** implementation details
_hardware should become _monitors
_hardware/services/ should become _hardware/workers/

_hardware/workers/__main__.py should be a thing, I think...?
_drivers should become _hardware/workers/drivers, maybe

OR

_hardware should become _monitors
_hardware/services should become _workers
_drivers should become _workers/drivers

_monitors would then be a sort of general type of plugin at some point
_workers are for routing events, and may either return or "morph" into
a printer.  _drivers implement hardware functionality irrespective of
any switchprint nonsese, and thus provide clean interface which a
printer may interact with the hardware without knowing anything about
the hardware.


** TODO add dbus interfaces to device driver
** TODO daemonize and create init script
This is both to report to the main thread that something was
enumerated or denumerated, and also to provide an interface in which
other programs can connect to the printer.


* extra-credit to-do list
** TODO use GDBus via gi instead of libdbus via python-dbus
to be future proof
** TODO clean up DBUS usage in accordance to whatever is best practice
whatever that may be
* radical architecting
Idk why I threw in the word "radical".  Sounds cool though.

For starters, this program represents only what is connected - and
other programs may do so as well.  I'm taking the quick-and-dirty
approach here, so I'm not only supporting sprinter derivative repraps
firmwares running on arduinos and arduino clones.

This entire component will probably be thrown out whole-sale at some
point, ethier due to obsolecence or it recieving lots of improvements.
For example, supporting the repetier protocol would be neat.  So would
support for makerbots.  But neither of those are really priorities for
me, though they may be priorities for other people to try to add.

** at the bottom
A little init script that spawns or kills the daemon.  The daemon
subprocess should instance a class that reprepsents the main dbus
interface, which should probably be something like
org.voxelpress.hardware or something.

** hardware detection
Udev events can probably be processed in the same process as the
daemon, but should be in a separate submodule, to make things cleaner.

** hardware drivers
Drivers in this case are additional modules (for now, there's going to
just be sprinter repraps).  Drivers are responsible for identifying
themselves.  A driver module is both imported by the main thread to
determine what events it can hook into, and can also call itself as a
subprocess.

The driver subprocess provides a dbus interface.  This does not
interact with the main thread, beyond reporting that the device is
attached or the device has been detached.

** printer control api
Printers can be accessed simultaneously by several other programs.
Anyone can read the printer's state, and send manual commands or start
up a stream.

When a command stream is created, the host software pasess a uuid to
represent the stream.  This functions like a lock - the program then
can proceed to dump commands into the stream, and then finishes by
closing the stream.  These commands are buffered, thus allowing the
program to be closed.

While other programs cannot add to the stream without knowing the
uuid, they can pause the print, as well as discard the stream.  There
is only one stream in memory at a time.

The control api should likely have calls for basic actions, like "move
axis", "heat up extruder n to k", "home", "set zero", and so on.

This would allow for host software to be written without hardcoding
anything like gcode.

** printer control lib
switchprint may as well just provide an api thats easy to use that
encapsulates the dbus api.
